'use strict';

var React = require('react');
var d3 = require('d3');
var DataSeries = require('./DataSeries');
var utils = require('../utils');

var $__0=       require('../common'),Chart=$__0.Chart,XAxis=$__0.XAxis,YAxis=$__0.YAxis,Tooltip=$__0.Tooltip;
var $__1=       require('../mixins'),CartesianChartPropsMixin=$__1.CartesianChartPropsMixin,DefaultAccessorsMixin=$__1.DefaultAccessorsMixin,ViewBoxMixin=$__1.ViewBoxMixin,TooltipMixin=$__1.TooltipMixin;

module.exports = React.createClass({

  mixins: [ CartesianChartPropsMixin, DefaultAccessorsMixin, ViewBoxMixin, TooltipMixin ],

  displayName: 'BarChart',

  propTypes: {
    chartClassName:         React.PropTypes.string,
    data:                   React.PropTypes.array.isRequired,
    hoverAnimation:         React.PropTypes.bool,
    height:                 React.PropTypes.number,
    margins:                React.PropTypes.object,
    rangeRoundBandsPadding: React.PropTypes.number,
    // https://github.com/mbostock/d3/wiki/Stack-Layout#offset
    stackOffset:            React.PropTypes.oneOf(['silhouette', 'expand', 'wigget', 'zero']),
    valuesAccessor:         React.PropTypes.func,
    title:                  React.PropTypes.string,
    width:                  React.PropTypes.number,
    xAxisClassName:         React.PropTypes.string,
    yAxisClassName:         React.PropTypes.string,
    yAxisTickCount:         React.PropTypes.number,
  },

  getDefaultProps:function() {
    return {
      chartClassName:         'rd3-barchart',
      hoverAnimation:         true,
      margins:                {top: 10, right: 20, bottom: 40, left: 45},
      rangeRoundBandsPadding: 0.25,
      stackOffset:            'zero',
      valuesAccessor:         function(d)  {return d.values;},
      xAxisClassName:         'rd3-barchart-xaxis',
      yAxisClassName:         'rd3-barchart-yaxis',
      yAxisTickCount:         4,
    };
  },

  _getStackedValuesMaxY:function(_data) {
    // in stacked bar chart, the maximum height we need for 
    // yScale domain is the sum of y0 + y
    var $__0=    this.props,valuesAccessor=$__0.valuesAccessor;
    return d3.max(_data, function(d) {
      return d3.max(valuesAccessor(d), function(d) {
        // where y0, y is generated by d3.layout.stack()
        return d.y0 + d.y;
      });
    });
  },

  _getStackedValuesMinY:function(_data) {
    var $__0=    this.props,valuesAccessor=$__0.valuesAccessor;
    return d3.min(_data, function(d) {
      return d3.min(valuesAccessor(d), function(d) {
        // where y0, y is generated by d3.layout.stack()
          return d.y0 + d.y;
      });
    });
  },

  _getLabels:function(firstSeries) {
    // we only need first series to get all the labels
    var $__0=     this.props,valuesAccessor=$__0.valuesAccessor,xAccessor=$__0.xAccessor;
    return valuesAccessor(firstSeries).map(xAccessor);
  },

  _stack:function() {
    // Only support columns with all positive or all negative values
    // https://github.com/mbostock/d3/issues/2265
    var $__0=       this.props,stackOffset=$__0.stackOffset,xAccessor=$__0.xAccessor,yAccessor=$__0.yAccessor,valuesAccessor=$__0.valuesAccessor;
    return d3.layout.stack()
                    .offset(stackOffset)
                    .x(xAccessor)
                    .y(yAccessor)
                    .values(valuesAccessor);
  },

  render:function() {

    var props = this.props;
    var yOrient = this.getYOrient();

    var _data = this._stack()(props.data);

    var $__0=     this.getDimensions(),innerHeight=$__0.innerHeight,innerWidth=$__0.innerWidth,trans=$__0.trans,svgMargins=$__0.svgMargins;

    var xScale = d3.scale.ordinal()
      .domain(this._getLabels(_data[0]))
      .rangeRoundBands([0, innerWidth], props.rangeRoundBandsPadding);

    var yScale = d3.scale.linear()
      .range([innerHeight, 0])
      .domain([Math.min(0, this._getStackedValuesMinY(_data)), this._getStackedValuesMaxY(_data)]);

    var series = props.data.map( function(item)  {return item.name;} );

    return (
      React.createElement("span", null, 
        React.createElement(Chart, {
          viewBox: this.getViewBox(), 
          legend: props.legend, 
          data: props.data, 
          margins: props.margins, 
          colors: props.colors, 
          colorAccessor: props.colorAccessor, 
          width: props.width, 
          height: props.height, 
          title: props.title, 
          shouldUpdate: !this.state.changeState
        }, 
          React.createElement("g", {transform: trans, className: props.chartClassName}, 
            React.createElement(YAxis, {
              yAxisClassName: props.yAxisClassName, 
              yAxisTickValues: props.yAxisTickValues, 
              yAxisLabel: props.yAxisLabel, 
              yAxisLabelOffset: props.yAxisLabelOffset, 
              yScale: yScale, 
              margins: svgMargins, 
              yAxisTickCount: props.yAxisTickCount, 
              tickFormatting: props.yAxisFormatter, 
              width: innerWidth, 
              height: innerHeight, 
              horizontalChart: props.horizontal, 
              xOrient: props.xOrient, 
              yOrient: yOrient, 
              gridHorizontal: props.gridHorizontal, 
              gridHorizontalStroke: props.gridHorizontalStroke, 
              gridHorizontalStrokeWidth: props.gridHorizontalStrokeWidth, 
              gridHorizontalStrokeDash: props.gridHorizontalStrokeDash}
            ), 
            React.createElement(XAxis, {
              xAxisClassName: props.xAxisClassName, 
              xAxisTickValues: props.xAxisTickValues, 
              xAxisLabel: props.xAxisLabel, 
              xAxisLabelOffset: props.xAxisLabelOffset, 
              xScale: xScale, 
              margins: svgMargins, 
              tickFormatting: props.xAxisFormatter, 
              width: innerWidth, 
              height: innerHeight, 
              horizontalChart: props.horizontal, 
              xOrient: props.xOrient, 
              yOrient: yOrient, 
              gridVertical: props.gridVertical, 
              gridVerticalStroke: props.gridVerticalStroke, 
              gridVerticalStrokeWidth: props.gridVerticalStrokeWidth, 
              gridVerticalStrokeDash: props.gridVerticalStrokeDash}
            ), 
            React.createElement(DataSeries, {
              yScale: yScale, 
              xScale: xScale, 
              margins: svgMargins, 
              _data: _data, 
              series: series, 
              width: innerWidth, 
              height: innerHeight, 
              colors: props.colors, 
              colorAccessor: props.colorAccessor, 
              hoverAnimation: props.hoverAnimation, 
              valuesAccessor: props.valuesAccessor, 
              onMouseOver: this.onMouseOver, 
              onMouseLeave: this.onMouseLeave}
              )
          )
        ), 
        (props.showTooltip ? React.createElement(Tooltip, React.__spread({},  this.state.tooltip)) : null)
      )
    );
  }

});
